import 'package:cloud_functions/cloud_functions.dart';
import 'package:ecommerce_app/data/repositories/auth_repo.dart';
import 'package:ecommerce_app/data/repositories/order_repo.dart';
import 'package:ecommerce_app/features/shop/controllers/cart_controller.dart';
import 'package:ecommerce_app/features/shop/controllers/wallet_controller.dart';
import 'package:ecommerce_app/features/shop/models/order_model.dart';
import 'package:flutter/material.dart';
import 'package:flutter_stripe/flutter_stripe.dart';
import 'package:get/get.dart';

enum PaymentMethod { wallet, card }

class CheckoutController extends GetxController {
  static CheckoutController get instance => Get.find();

  final _cartController = CartController.instance;
  final _walletController = Get.put(WalletController());
  final _orderRepository = Get.put(OrderRepository());
  final _functions = FirebaseFunctions.instance;

  final Rx<PaymentMethod> selectedPaymentMethod = PaymentMethod.card.obs;
  final RxBool isLoading = false.obs;

  // Selected Card for Stripe (Stored Payment Method ID)
  final RxString selectedPaymentMethodId = ''.obs;
  final RxList<Map<String, dynamic>> savedCards = <Map<String, dynamic>>[].obs;

  @override
  void onInit() {
    super.onInit();
    // Default to card
    selectedPaymentMethod.value = PaymentMethod.card;
    fetchPaymentMethods();
  }

  void selectPaymentMethod(PaymentMethod method) {
    selectedPaymentMethod.value = method;
  }

  // Fetch saved cards from Stripe
  Future<void> fetchPaymentMethods() async {
    try {
      final user = AuthenticationRepository.instance.authUser;
      if (user == null) return;

      // We need to get the Stripe Customer ID first.
      // This is usually stored in the User document.
      // Assuming we have logic to get it, or we trigger 'createStripeCustomer' if null
      // For now, let's assume the helper logic exists or we call the function directly.
      
      final customerResult = await _functions.httpsCallable('createStripeCustomer').call({
        'email': user.email,
        'name': user.displayName ?? 'User',
      });
      final customerId = customerResult.data['customerId'];

      final result = await _functions.httpsCallable('getPaymentMethods').call({
         'customerId': customerId,
      });

      final List<dynamic> data = result.data['paymentMethods'];
      savedCards.assignAll(data.cast<Map<String, dynamic>>());
      
      if (savedCards.isNotEmpty) {
        selectedPaymentMethodId.value = savedCards.first['id'];
      }

    } catch (e) {
      print('Error fetching cards: $e');
    }
  }


  Future<void> processPayment(BuildContext context) async {
    try {
      isLoading.value = true;

      final double amount = _cartController.total;
      if (amount <= 0) {
        throw 'Invalid amount';
      }

      // 1. Create Order Model (Pending Status)
      final newOrder = OrderModel(
        id: '', // Will be generated by Firestore
        userId: AuthenticationRepository.instance.userId,
        status: 'Processing',
        totalAmount: amount,
        orderDate: DateTime.now(),
        paymentMethod: selectedPaymentMethod.value == PaymentMethod.wallet ? 'Wallet' : 'Credit Card',
        items: List<Map<String, dynamic>>.from(_cartController.cartItems),
        deliveryDate: DateTime.now().add(const Duration(days: 3)), // Estimate
      );
      
      // Temporarily use a random ID for logic, but Firestore will assign real one
      // Actually, for wallet payment we need orderId passed to function.
      // We can generate one or let Firestore generate.
      // Let's create the order doc first with 'Pending Payment' status?
      // Or just pass a reference ID. Let's use timestamp for now as Ref.
      final String orderRefId = DateTime.now().millisecondsSinceEpoch.toString();


      if (selectedPaymentMethod.value == PaymentMethod.wallet) {
        await _payWithWallet(amount, orderRefId);
      } else {
        await _payWithCard(amount, orderRefId);
      }

      // 2. Save Order to Firestore (Only if payment succeeded)
      await _orderRepository.saveOrder(newOrder, AuthenticationRepository.instance.userId);

      // 3. Clear Cart
      _cartController.cartItems.clear(); // Clear directly or use clearCart()

      // 4. Success Navigation
      Get.offAllNamed('/navigation'); // Or to Order Success Screen
      Get.snackbar(
        'Success', 
        'Order placed successfully!',
        backgroundColor: Colors.green.withOpacity(0.1),
        colorText: Colors.green,
      );

    } catch (e) {
      Get.snackbar(
        'Error', 
        e.toString(),
        backgroundColor: Colors.red.withOpacity(0.1),
        colorText: Colors.red,
      );
    } finally {
      isLoading.value = false;
    }
  }

  Future<void> _payWithWallet(double amount, String orderId) async {
    // Check balance locally first
    if (_walletController.totalBalance.value < amount) {
      throw 'Insufficient wallet balance';
    }

    final callable = _functions.httpsCallable('payWithWallet');
    final result = await callable.call({
      'amount': amount,
      'orderId': orderId,
    });

    if (result.data['success'] != true) {
      throw 'Wallet payment failed';
    }
  }

  Future<void> _payWithCard(double amount, String orderId) async {
    // 1. Get Customer ID
    final user = AuthenticationRepository.instance.authUser;
    final customerResult = await _functions.httpsCallable('createStripeCustomer').call({
        'email': user?.email,
        'name': user?.displayName ?? 'User',
    });
    final customerId = customerResult.data['customerId'];

    // 2. Create Payment Intent
    final intentResult = await _functions.httpsCallable('createPaymentIntent').call({
      'amount': amount,
      'customerId': customerId,
      'paymentMethodId': selectedPaymentMethodId.value, // Use selected saved card or new
      'metadata': {'orderId': orderId},
    });

    final clientSecret = intentResult.data['clientSecret'];

    // 3. Confirm Payment (Frontend)
    // If automatic confirmation at server (off_session: true, confirm: true) succeeded:
    if (intentResult.data['status'] == 'succeeded') {
       return; // Done
    } 

    // Used if we need 3DS or if manual confirmation is needed
    await Stripe.instance.confirmPayment(
      paymentIntentClientSecret: clientSecret,
      data: const PaymentMethodParams.card(
        paymentMethodData: PaymentMethodData(),
      ), 
    );
  }
}
